Functions for the master: closures and scopes

    Closures make a lot of things a whole lot easier, and other things possible. 
  Traditionally, closures have been a feature of purely functional programming languages. They
  are crossing over into mainstream development. This is good, as they can drastically simplify
  complex operations. 
  
    Closures are a side effect of how scopes work in JS. 
    
  Understanding Closures
      A closure allows a function to access and manipulate variables that are external to that function.
    Closures allow a function to access all the variables, as well as other functions, that are in scope when
    the function itself is defined. 
    
      That may seem intuitive until you remember that a declared function can be called at any later time,
    even after the scope in which it was declared has gone away. 
    
      When we declare an inner function inside an outer function, not only is the function declaration
    defined, but a closure is created that encompasses the functino definition as well as ALL variables
    in scope at the point of function definition!!
    
    That's what closures are all about. They create a "safety bubble" of the function and the variables
    in scope at the point of the functions. This ensures that the function has all it needs to execute. 
    It's important to remember that each function that accesses information via a closure has a
    "ball and chain" attached to it. All that information needs to be held in memory until it's 
    absolutely clear to the engine that it's no longer needed. 
    
  Putting closures to work
    Mimicking private variables:
      Many programming languages use private variables - properties of an object that are hidden
      from outside parties. Unfortunately, JS doesn't have native support for private variables.
      But by using a closure, we can achieve an acceptable approximation.
      ex:
        function Ninja() {
          var feints = 0;
          this.getFeints = function() {
            return feints;
          };
          this.feint = function() {
            feints++;
          };
        }
        
        var ninja1 = new Ninja();
        ninja1.feint();
        console.log(ninja1.feints);
        // undefined
        console.log(ninja1.getFeints);
        // 1
        
        This heavily mimics the concept of a getter that you know from c++. We can use the accessor method
      to obtain the value of the private vairable but that we can't access it directly. This prevents us
      from making uncontrolled changes to the value of the variable.
      Even though the function scope has closed, there is a version of feints stored in each new
      ninja object. This is another example of a closure and a glimpse into the world of object-oriented
      Javascript. 
      
        Recall that when using the new keyword on a function, a new object instance is created, and the function
      is called with that new object as its context. So 'this' within the function refers to a newly instantiated
      object. 
      
    Using closures with callbacks
        Another common use of closures occurs when dealing with callbacks - when a function is called
      at an unspecified later time. Often, within such functions, we frequently need to access outside
      data. 
        If we keep variables in global scope, we need a set of variables for EACH function call, otherwise
      they'll step all over each other, trying to use the same set of variables to keep track of multiple states. 
      By defining the variables inside the function, and by relying on closures to make them available to the timer
      callback invocations, each animation gets its own private "bubble" of variables.
    
      
      


