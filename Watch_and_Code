Version 1:
    -Arrays have various methods associated. One of them is the .push method where it will add what's
    in the parentheses to the end of the array. This function adds to the array and returns the length
    of the array.
Version 2:
    -Think about the sandwich recipe when talking about functions. 
    ex:
    function makeSandwichWith(filling) {
      Get one slice of bread;
      Add filling;
      Put a slice of bread on top;
    }
    The parameter is a generalized term that encompasses all of the uses of the function
Version 3:
    -What you would call datamembers of objects in c++, are called properties in JS.
    -You do not need to define the variables in an object. Just use the key-value pair notation.
    -You still access them the same way as you would in c++ using the dot notation.
    -To include functions as properties (methods), you still use the key-value pair, but the value is an
    anonymous function.
    -When you want to reference the object that you are in, JS has a keyword *this* that allows you 
    to reference the object.
Version 4:
    -Parts of a for-loop: 
        -Initialization
        -Condition
        -final-expression
    -It is good form to use array.length as part of the condition in order to make the for loop dynamic
Version 5:
    -Included if, else statements.
Verson 6: 
    -When an object is created, the variable actually saves the memory location of the object, which makes
    object comparisons pretty much always false unless you save one as the other.
    
In order to start the debugger, just put a debugger; statement in the JS where you want the program to start.
You can make a function that takes a function and just runs it with the debugger. 
    
Refactoring is nonfunctional changes to code to make it easier to use or less complicated.

Button elements have an attribute, ex: onclick="handlers.displayTodos()" which makes it simpler than having
add event listener lines.

The div tag groups elements together and also puts them on a new line.

Javascript has a built in setTimeout function that takes a function and a time in milleseconds. It will run that function when 
the given time has elapsed. 
    ex: setTimeout(console.log('hello'), 5000);
    
Functions that accept other functions or return other functions are Higher-Order functions. The functions that are passed to Higher-Order
functions are called Callback functions.

If you want to have a general event listener for a section of the DOM, you can apply this event listener
on the largest element in that area and make it decide which to affect.

Search up event delegation.

forEach can take a second argument where you pass in this. This allows you to have this equal to the object that
forEach was called in, as the Callback function is not a method of the object.

This keyword cheatsheet: https://github.com/gordonmzhu/cheatsheet-js

The window object represents the browser window.
When you bind a function, it can never be bound again. 
Bind, apply, and call are all basically the same with a few variations.


